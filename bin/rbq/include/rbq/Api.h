#ifndef RBQ_API_H
#define RBQ_API_H

#if defined(PRIVATE)
#include "SharedMemory.h"
#endif
#include <Eigen/Dense>

class RBQ_API
{
public:
    /**
     * @brief Constructs an RBQ_API object with a specific process ID.
     *
     * This constructor assigns a unique process ID to this control instance.
     * Process IDs in the range [20, 39] are reserved for user-level applications.
     * This allows multiple user processes or threads to interact with the robot independently.
     *
     * Since multiple processes can attempt to control the robot simultaneously,
     * each joint uses a **Motion Owner** mechanism to ensure safety and consistency.
     * Only the process that owns a joint can control it.
     * To take control of a joint, call `setMotionOwner()` before sending any reference commands.
     *
     * @param _processId The ID of this process (should be in range [20, 39] for user applications).
     */
    RBQ_API(const int &_processId); //for user id range = [20, 39]
#if defined(PRIVATE)
    RBQ_API(const std::string &_processName); //for internal process
#endif
    ~RBQ_API();

    struct Motion {
        /**
         * @defgroup MotionAPI Motion API
         * @brief Command robot locomotion.
         *
         * This group provides access to call the command function of the robot locomotion.
         *
         */

        Motion(RBQ_API* parent) : m_parent(parent) {}

        void startProgram(const bool &_start, const int &_id);

        void autoStart();

        void staticReady();

        void staticGround();

        void ground();

        void ready();

        void walk();

        void wave();

        void stairs();

        void run();

        void aim();

        void docking();

        void jump();

        void eStop();

        void cruiseWalk(const bool &_increase = true);

        void parametersUpdate(const uint8_t &bodyHeight, const uint8_t &speed, const uint8_t &footHeight);

        void zmpCalibrate();

        void calibrateAccelerometer();

        void lockAllJoint();

    private:
        RBQ_API* m_parent = nullptr;  // RBQ_API class pointer
    };
    Motion motion{this};

    struct JOINT {
        /**
         * @defgroup JointControlAPI Joint Control API
         * @brief APIs for controlling joint-level commands such as position, torque, and gains.
         *
         * This group includes functions to set joint position references, torque references,
         * and control gains (Kp and Kd) for each joint. These APIs are designed to support
         * real-time joint control in a multi-process system architecture.
         *
         * ### Motion Owner
         * Although there is only one physical robot, multiple processes may exist that generate reference commands.
         * In order for a specific process to control a particular joint, it must first acquire motion ownership
         * of that joint. If a process sets references without owning the joint, those references will not be applied
         * to the robot. To ensure control, call setMotionOwner(const int &_jointId) before using any reference-setting functions
         * (e.g., position, torque, gain).
         *
         * ### Damping Gain Modes
         * - **Dgain Mode 1**:
         *   vel_ref is generated by differentiating pos_ref within the low-level motor controller.
         *   The applied joint torque is:
         *   torque = kp * (pos_ref - pos_meas) + kd * (vel_ref - vel_meas) + torque_feedforward
         *
         * - **Dgain Mode 2**:
         *   vel_ref is fixed to zero.
         *   The applied joint torque is:
         *   torque = kp * (pos_ref - pos_meas) + kd * (-vel_meas) + torque_feedforward
         */

        JOINT(RBQ_API* parent) : m_parent(parent) {}

        /**
         * @ingroup JointControlAPI
         * @brief Enumeration of all joint IDs in the quadruped robot.
         *
         * The robot has 4 legs: hind-left, hind-right, front-left, and front-right.
         * Each leg has 3 joints: roll (R), pitch (P), and knee (K).
         * This enum provides symbolic names for each joint, corresponding to their index.
         */
        enum class JointID : int {
            HRR = 0,  ///< Hind-right roll joint
            HRP = 1,  ///< Hind-right pitch joint
            HRK = 2,  ///< Hind-right knee joint

            HLR = 3,  ///< Hind-left roll joint
            HLP = 4,  ///< Hind-left pitch joint
            HLK = 5,  ///< Hind-left knee joint

            FRR = 6,  ///< Front-right roll joint
            FRP = 7,  ///< Front-right pitch joint
            FRK = 8,  ///< Front-right knee joint

            FLR = 9,  ///< Front-left roll joint
            FLP = 10, ///< Front-left pitch joint
            FLK = 11  ///< Front-left knee joint
        };


        // ───────────────────────────────────────────────────────────────
        // Joint Torque Limits by Joint Type [Nm]
        // ───────────────────────────────────────────────────────────────

        static constexpr float TORQUE_ROLL_UPPER  = 104.f;   ///< @brief Upper bound torque for roll joints [Nm] @ingroup JointControlAPI
        static constexpr float TORQUE_ROLL_LOWER  = -104.f;  ///< @brief Lower bound torque for roll joints [Nm] @ingroup JointControlAPI

        static constexpr float TORQUE_PITCH_UPPER = 104.f;   ///< @brief Upper bound torque for pitch joints [Nm] @ingroup JointControlAPI
        static constexpr float TORQUE_PITCH_LOWER = -104.f;  ///< @brief Lower bound torque for pitch joints [Nm] @ingroup JointControlAPI

        static constexpr float TORQUE_KNEE_UPPER  = 140.f;   ///< @brief Upper bound torque for knee joints [Nm] @ingroup JointControlAPI
        static constexpr float TORQUE_KNEE_LOWER  = -70.f;   ///< @brief Lower bound torque for knee joints [Nm] @ingroup JointControlAPI


        /**
         * @brief Assigns motion ownership of the specified joint to the current process.
         *
         * In a multi-process control architecture, multiple processes may generate reference commands.
         * However, only the process that owns a joint (the motion owner) can actively control it.
         *
         * This function assigns the current process as the motion owner of the specified joint.
         * When ownership is assigned, the existing reference values (position, torque, Kp, Kd)
         * are initialized using the values from the default system process.
         *
         * This function must be called once before using any reference-setting functions
         * (e.g., position, torque, gain). Once motion ownership is acquired, it remains valid
         * until another process explicitly takes ownership of the same joint.
         * If this process is not the motion owner, any reference it sets will be ignored by the controller.
         *
         * @param _jointId The joint ID to take ownership of (valid range: 0 to 11).
         *
         * @return Returns 1 if ownership is successfully assigned;
         *         -2 if _jointId is out of range.
         *
         * @ingroup JointControlAPI
         */
        int setMotionOwner(const int &_jointId);

        /**
         * @brief Overload using JointID.
         * @see setMotionOwner(const int&)
         * @ingroup JointControlAPI
         */
        int setMotionOwner(const JointID _jointId){
            return setMotionOwner(static_cast<int>(_jointId));
        }

        /**
         * @brief Sets the joint position reference.
         *
         * This function sets the desired joint position (in radians) for the specified joint.
         *
         * @param _jointId The joint ID (valid range: 0 to 11).
         * @param _joint_pos_rad The desired joint position in radians.
         *
         * @return Returns 1 if the position is successfully set and the current process is the motion owner;
         *         -1 if the position is set but the current process is not the motion owner;
         *         -2 if _jointId is out of range.
         *
         * @note This function requires motion ownership. Use setMotionOwner() before calling.
         * @ingroup JointControlAPI
         */
        int setPosRef(const int &_jointId, const float &_joint_pos_rad);

        /**
         * @brief Overload using JointID.
         * @see setPosRef(const int&, const float&)
         * @ingroup JointControlAPI
         */
        int setPosRef(const JointID _jointId, const float &_joint_pos_rad){
            return setPosRef(static_cast<int>(_jointId), _joint_pos_rad);
        }

        /**
         * @brief Sets the joint torque reference in Newton-meters (Nm).
         *
         * This function sets the desired torque value for a specific joint.
         * The input torque is clamped to a valid range based on the joint type:
         * - Roll joints:   [TORQUE_ROLL_LOWER, TORQUE_ROLL_UPPER]
         * - Pitch joints:  [TORQUE_PITCH_LOWER, TORQUE_PITCH_UPPER]
         * - Knee joints:   [TORQUE_KNEE_LOWER, TORQUE_KNEE_UPPER]
         *
         * If the input value is outside the allowed range, it is clamped to the nearest valid value.
         * To ensure the reference takes effect, the calling process must first acquire motion ownership
         * using `setMotionOwner()`.
         *
         * @param _jointId The ID of the joint (valid range: 0 to 11).
         * @param _torque_Nm The desired torque in Newton-meters (Nm).
         *
         * @return Returns:
         * -  1 if the torque is set and the current process is the motion owner.
         * -  2 if the torque is set but the input value was clamped.
         * - -1 if the torque is set but the current process is not the motion owner.
         * - -2 if _jointId is out of range.
         *
         * @note This function requires motion ownership. Use setMotionOwner() before calling.
         * @ingroup JointControlAPI
         */
        int setTorqueRef(const int &_jointId, const float &_torque_Nm);

        /**
         * @brief Overload using JointID.
         * @see setTorqueRef(const int&, const float&)
         * @ingroup JointControlAPI
         */
        int setTorqueRef(const JointID _jointId, const float &_torque_Nm){
            return setTorqueRef(static_cast<int>(_jointId), _torque_Nm);
        }

        /**
         * @brief Sets the joint position gain (Kp) with quantization.
         *
         * This function sets the desired Kp gain for a specified joint after quantizing it based on predefined resolution steps.
         * For roll/pitch joints (IDs: 0, 1, 3, 4, 6, 7, 9, 10), the quantization step is 17.62734 Nm/rad, and for knee joints (IDs: 2, 5, 8, 11),
         * the quantization step is 25.55443 Nm/rad. The quantized gain is applied and the actual gain (nearest multiple of the resolution step)
         * is returned via the real_kp_ parameter.
         *
         * @param _jointId The ID of the joint (valid range: 0 to 11).
         * @param _set_kp_ The desired Kp gain value in Nm/rad (valid range: 0.0 to 5000.0).
         * @param real_kp_ Reference parameter to receive the actual applied gain value after quantization.
         *
         * @return  1 if the gain is set and the current process is the motion owner;
         *         -1 if the gain is set but the current process is not the motion owner;
         *         -2 if _jointId is out of range;
         *         -3 if _set_kp_ is out of range.
         *
         * @note This function requires motion ownership. Use setMotionOwner() before calling.
         *
         * @ingroup JointControlAPI
         */
        int setGainKp(const int &_jointId, const float &_set_kp, float &real_kp_);

        /**
         * @brief Overload using JointID.
         * @see setGainKp(const int&, const float&, float&)
         * @ingroup JointControlAPI
         */
        int setGainKp(const JointID _jointId, const float &_set_kp, float &real_kp_){
            return setGainKp(static_cast<int>(_jointId), _set_kp, real_kp_);
        }

        /**
         * @brief Overload without return gain value.
         * @see setGainKp(const int&, const float&, float&)
         * @ingroup JointControlAPI
         */
        int setGainKp(const int &_jointId, const float &_set_kp){
            float dummy;
            return setGainKp(_jointId, _set_kp, dummy);
        }

        /**
         * @brief Overload using JointID, and without return gain value.
         * @see setGainKp(const int&, const float&, float&)
         * @ingroup JointControlAPI
         */
        int setGainKp(const JointID _jointId, const float &_set_kp){
            float dummy;
            return setGainKp(static_cast<int>(_jointId), _set_kp, dummy);
        }

        /**
         * @brief Sets the joint damping gain (Kd) with quantization.
         *
         * This function sets the desired Kd gain for a specified joint after quantizing it based on predefined resolution steps.
         * For roll/pitch joints (IDs: 0, 1, 3, 4, 6, 7, 9, 10), the quantization step is 0.035255 Nm*s/rad, and for knee joints (IDs: 2, 5, 8, 11),
         * the quantization step is 0.051109 Nm*s/rad. The quantized gain is applied and the actual gain (i.e. the nearest multiple of the resolution step)
         * is returned via the real_kd_ parameter.
         *
         * @param _jointId The ID of the joint (valid range: 0 to 11).
         * @param _set_kd The desired Kd gain value in Nm*s/rad (valid range: 0.0 to 10.0).
         * @param real_kd_ Reference parameter to receive the actual applied damping gain value after quantization.
         *
         * @return Returns  1 if the gain is set and the current process is the motion owner;
         *         Returns -1 if the gain is set but the current process is not the motion owner;
         *         Returns -2 if _jointId is out of range;
         *         Returns -3 if _set_kd is out of range.
         *
         * @note This function requires motion ownership. Use setMotionOwner() before calling.
         *
         * @ingroup JointControlAPI
         */
        int setGainKd(const int &_jointId, const float &_set_kd, float &real_kd_);

        /**
         * @brief Overload using JointID.
         * @see setGainKd(const int&, const float&, float&)
         * @ingroup JointControlAPI
         */
        int setGainKd(const JointID _jointId, const float &_set_kd, float &real_kd_){
            return setGainKd(static_cast<int>(_jointId), _set_kd, real_kd_);
        }

        /**
         * @brief Overload without return gain value.
         * @see setGainKd(const int&, const float&, float&)
         * @ingroup JointControlAPI
         */
        int setGainKd(const int &_jointId, const float &_set_kd) {
            float dummy;
            return setGainKd(_jointId, _set_kd, dummy);
        }

        /**
         * @brief Overload using JointID, without return gain value.
         * @see setGainKd(const int&, const float&, float&)
         * @ingroup JointControlAPI
         */
        int setGainKd(const JointID _jointId, const float &_set_kd) {
            float dummy;
            return setGainKd(static_cast<int>(_jointId), _set_kd, dummy);
        }

        /**
         * @brief Returns the current joint position in radians.
         *
         * This function retrieves the measured joint angle for the specified joint.
         * The value is obtained from the sensor and expressed in radians.
         *
         * @param _jointId The ID of the joint (valid range: 0 to 11).
         * @param joint_pos_rad_ Reference variable that will be filled with the measured joint position (in radians).
         *
         * @return Returns 1 on success.
         *
         * @ingroup JointControlAPI
         */
        int getPos(const int &_jointId, float &joint_pos_rad_);

        /**
         * @brief Overload using JointID.
         * @see getPos(const int&, float&)
         * @ingroup JointControlAPI
         */
        int getPos(const JointID _jointId, float &joint_pos_rad_){
            return getPos(static_cast<int>(_jointId), joint_pos_rad_);
        }

        /**
         * @brief Returns the current joint velocity in radians per second.
         *
         * This function retrieves the measured joint angular velocity for the specified joint.
         * The value is obtained from the sensor and expressed in radians per second (rad/s).
         *
         * @param _jointId The ID of the joint (valid range: 0 to 11).
         * @param joint_vel_rad_per_sec_ Reference variable that will be filled with the measured joint velocity (in rad/s).
         *
         * @return Returns 1 on success.
         *
         * @ingroup JointControlAPI
         */
        int getVel(const int &_jointId, float &joint_vel_rad_per_sec_);

        /**
         * @brief Overload using JointID.
         * @see getVel(const int&, float&)
         * @ingroup JointControlAPI
         */
        int getVel(const JointID _jointId, float &joint_vel_rad_per_sec_){
            return getVel(static_cast<int>(_jointId), joint_vel_rad_per_sec_);
        }

        /**
         * @brief Returns the current joint torque in Newton-meters (Nm).
         *
         * This function retrieves the measured torque value applied to the specified joint.
         * The value is obtained from the sensor and expressed in Newton-meters.
         *
         * @param _jointId The joint ID (valid range: 0 to 11).
         * @param joint_torque_ Reference variable that will be filled with the measured joint torque (in Nm).
         *
         * @return Returns 1 on success.
         * @ingroup JointControlAPI
         */
        int getTorque(const int &_jointId, float &joint_torque_);

        /**
         * @brief Overload using JointID.
         * @see getTorque(const int&, float&)
         * @ingroup JointControlAPI
         */
        int getTorque(const JointID _jointId, float &joint_torque_){
            return getTorque(static_cast<int>(_jointId), joint_torque_);
        }

        /**
         * @brief Retrieves the joint position gain (Kp).
         *
         * This function calculates and returns the current joint position gain value in Nm/rad for the specified joint.
         * It applies a resolution of 17.62734 Nm/rad for roll/pitch (IDs: 0, 1, 3, 4, 6, 7, 9, 10) joints and 25.55443 Nm/rad for knee joints (IDs: 2, 5, 8, 11).
         *
         * @param joint_kp_ Reference parameter to receive the gain value in Nm/rad.
         * @param _jointId The joint ID (valid range: 0 to 11).
         *
         * @return Returns 1 if the gain is successfully retrieved; returns -2 if the joint ID is out of range.
         * @ingroup JointControlAPI
         */
        int getGainKp(const int &_jointId, float &joint_kp_);

        /**
         * @brief Overload using JointID.
         * @see getGainKp(const int&, float&)
         * @ingroup JointControlAPI
         */
        int getGainKp(const JointID _jointId, float &joint_kp_){
            return getGainKp(static_cast<int>(_jointId), joint_kp_);
        }

        /**
         * @brief Retrieves the joint damping gain (Kd).
         *
         * This function calculates and returns the current joint damping gain value in Nm*s/rad for the specified joint.
         * It uses a resolution of 0.035255 Nm*s/rad for roll/pitch joints (IDs: 0, 1, 3, 4, 6, 7, 9, 10) and 0.051109 Nm*s/rad for knee joints (IDs: 2, 5, 8, 11).
         *
         * @param joint_kd_ Reference parameter to receive the damping gain value in Nm*s/rad.
         * @param _jointId The joint ID (valid range: 0 to 11).
         *
         * @return Returns 1 if the gain is successfully retrieved; returns -2 if the joint ID is out of range.
         * @ingroup JointControlAPI
         */
        int getGainKd(const int &_jointId, float &joint_kd_);

        /**
         * @brief Overload using JointID.
         * @see getGainKd(const int&, int&)
         * @ingroup JointControlAPI
         */
        int getGainKd(const JointID _jointId, float &joint_kd_){
            return getGainKd(static_cast<int>(_jointId), joint_kd_);
        }


        int getPosRef(const int &_jointId, float &joint_pos_ref_);

        int getPosRef(const JointID _jointId, float &joint_pos_rad_){
            return getPosRef(static_cast<int>(_jointId), joint_pos_rad_);
        }

        int getTorqueRef(const int &_jointId, float &joint_torque_ref_);

        int getTorqueRef(const JointID _jointId, float &joint_torque_){
            return getTorqueRef(static_cast<int>(_jointId), joint_torque_);
        }

        int getGainKpRef(const int &_jointId, float &joint_kp_ref_);

        int getGainKpRef(const JointID _jointId, float &joint_kp_ref_){
            return getGainKpRef(static_cast<int>(_jointId), joint_kp_ref_);
        }

        int getGainKdRef(const int &_jointId, float &joint_kd_ref_);

        int getGainKdRef(const JointID _jointId, float &joint_kd_ref_){
            return getGainKdRef(static_cast<int>(_jointId), joint_kd_ref_);
        }

        int getMotionOwner(const int &_jointId, int &joint_processID_);
        int getMotionOwner(const JointID _jointId, int &joint_processID_){
            return getMotionOwner(static_cast<int>(_jointId), joint_processID_);
        }
    private:
        RBQ_API* m_parent = nullptr;  // RBQ_API class pointer
    };
    JOINT Joint{this};

    struct IMU {
        /**
         * @defgroup IMUSensorAPI IMU Sensor API
         * @brief APIs for accessing IMU sensor data such as orientation, angular velocity, and linear acceleration.
         *
         * These functions provide access to the robot's onboard IMU sensor data in different representations,
         * including quaternion, roll-pitch-yaw (RPY), angular velocity (gyro), and linear acceleration.
         *
         * ### Robot Coordinate System
         * - +X: Forward (facing direction of the robot)
         * - +Y: Left
         * - +Z: Upward
         *
         * ### IMU Sensor Placement
         * The IMU sensor is located with an offset from the robot's body frame center:
         * - Offset (in meters): (0.00665, 0.0, -0.0404)
         *
         * All IMU-related data is expressed in this coordinate frame and reflects measurements from this fixed sensor position.
         */

        IMU(RBQ_API* parent) : m_parent(parent) {}

        /**
         * @brief Returns the IMU orientation as a quaternion (w, x, y, z).
         *
         * @param out_imu_ Reference to an Eigen::Quaternion<float> that will be filled with orientation data.
         * @return Returns 1 on success.
         *
         * @ingroup IMUSensorAPI
         */
        int getQuaternion(Eigen::Quaternion<float> &out_imu_);

        /**
         * @brief Returns the IMU orientation as roll, pitch, and yaw angles (in radians).
         *
         * The angles are computed from the quaternion using the Z-Y-X Euler angle convention (yaw → pitch → roll).
         * The output ranges are:
         * - Roll  ∈ [-π, π]
         * - Pitch ∈ [-π/2, π/2]
         * - Yaw   ∈ [-π, π]
         *
         * @param out_rpy_ Reference to a 3D vector that will be filled with (roll, pitch, yaw) in radians.
         * @return Returns 1 on success.
         *
         * @ingroup IMUSensorAPI
         */
        int getRPY(Eigen::Matrix<float, 3, 1> &out_rpy_);

        /**
         * @brief Returns the IMU angular velocity (gyroscope) in rad/s.
         *
         * The output is a 3D vector where each component represents the angular velocity (rate of rotation)
         * around the corresponding axis of the robot:
         * - X: roll rate
         * - Y: pitch rate
         * - Z: yaw rate
         *
         * All values are in radians per second (rad/s).
         * The measurement range is ±2000 deg/s(±34.9 rad/s).
         *
         * @param out_gyro_ Reference to an Eigen::Matrix<float, 3, 1> to store angular velocity.
         * @return Returns 1 on success.
         *
         * @ingroup IMUSensorAPI
         */
        int getGyro(Eigen::Matrix<float, 3, 1> &out_gyro_);

        /**
         * @brief Returns the IMU linear acceleration in m/s².
         *
         * The output is a 3D vector where each component represents the linear acceleration along
         * the corresponding axis of the robot:
         * - X: forward/backward acceleration
         * - Y: lateral (left/right) acceleration
         * - Z: vertical (up/down) acceleration
         *
         * All values are expressed in meters per second squared (m/s²).
         * The typical measurement range is ±16g (±156.96 m/s²).
         *
         * @param out_acc_ Reference to an Eigen::Matrix<float, 3, 1> to store acceleration data.
         * @return Returns 1 on success.
         *
         * @ingroup IMUSensorAPI
         */
        int getAcc(Eigen::Matrix<float, 3, 1> &out_acc_);

        int InitializeImu();

    private:
        RBQ_API* m_parent = nullptr;  // RBQ_API class pointer
    };
    IMU Imu{this};

    struct Gamepad {
        /**
         * @defgroup GamepadAPI Gamepad API
         * @brief Access joystick, trigger, and button inputs from the gamepad.
         *
         * This group provides access to the current state of the connected gamepad,
         * including analog joystick positions, trigger values, and digital button states.
         *
         * Joystick jog values and trigger values are normalized to [-1.0, 1.0] or [0.0, 1.0]
         * depending on the axis. Buttons return boolean states.
         *
         * This gamepad mapping is valid for Logitech F710 in 'X' mode
         */

        /**
         * @brief Enumeration of all button types on the gamepad.
         * @ingroup GamepadAPI
         */
        enum class Button {
            A,          ///< Face buttons
            B,          ///< Face buttons
            X,          ///< Face buttons
            Y,          ///< Face buttons
            LB,         ///< Left shoulder buttons
            RB,         ///< Right shoulder buttons
            BACK,       ///< System buttons
            START,      ///< System buttons
            LOGITECH,   ///< Central logo button
            LJOG,       ///< Jog stick clicks
            RJOG,       ///< Jog stick clicks
            AR_UP,      ///< D-pad directions
            AR_DOWN,    ///< D-pad directions
            AR_LEFT,    ///< D-pad directions
            AR_RIGHT,   ///< D-pad directions
        };

        Gamepad(RBQ_API* parent) : m_parent(parent) {}

        /**
         * @brief Gets the left joystick's X-axis input value.
         * @param out_left_jog_x_ Reference to store value in range [-1.0, 1.0].
         * @return 1 on success, 0 if shared memory is not accessible.
         * @ingroup GamepadAPI
         */
        int getLeftJogX(float &out_left_jog_x_);

        /**
         * @brief Gets the left joystick's Y-axis input value.
         * @param out_left_jog_y_ Reference to store value in range [-1.0, 1.0].
         * @return 1 on success, 0 if shared memory is not accessible.
         * @ingroup GamepadAPI
         */
        int getLeftJogY(float &out_left_jog_y_);

        /**
         * @brief Gets the value of the left trigger.
         * @param out_left_trigger_ Reference to store value in range [0.0, 1.0].
         * @return 1 on success, 0 if shared memory is not accessible.
         * @ingroup GamepadAPI
         */
        int getLeftTrigger(float &out_left_trigger_);

        /**
         * @brief Gets the right joystick's X-axis input value.
         * @param out_right_jog_x_ Reference to store value in range [-1.0, 1.0].
         * @return 1 on success, 0 if shared memory is not accessible.
         * @ingroup GamepadAPI
         */
        int getRightJogX(float &out_right_jog_x_);

        /**
         * @brief Gets the right joystick's Y-axis input value.
         * @param out_right_jog_y_ Reference to store value in range [-1.0, 1.0].
         * @return 1 on success, 0 if shared memory is not accessible.
         * @ingroup GamepadAPI
         */
        int getRightJogY(float &out_right_jog_y_);

        /**
         * @brief Gets the value of the right trigger.
         * @param out_right_trigger_ Reference to store value in range [0.0, 1.0].
         * @return 1 on success, 0 if shared memory is not accessible.
         * @ingroup GamepadAPI
         */
        int getRightTrigger(float &out_right_trigger_);

        /**
         * @brief Gets the state of a digital gamepad button.
         * @param _ButtonID The button ID to query.
         * @param out_state_ Reference to store button state (true if pressed).
         * @return 1 on success, 0 if shared memory is not accessible, -1 for invalid Button ID.
         * @ingroup GamepadAPI
         */
        int getButtonState(const Button _ButtonID, bool &out_state_);


        int setLeftJogX(const float &left_jog_x_);
        int setLeftJogY(const float &left_jog_y_);

        int setButtonState(const Button _ButtonID, bool &state_);

        int sendCommand();

    private:
        RBQ_API* m_parent = nullptr;  // RBQ_API class pointer

#if defined(PRIVATE)
        JOY_INFO m_joy;
#endif
    };
    Gamepad gamepad{this};

#if defined(PRIVATE)
    struct Command {
        Command(RBQ_API* parent) : m_parent(parent) {

        }

        int getUserCommand(int &out_command_);
        int getUserParaInt(const int &_index, int &out_parameter_);
        int getUserParaChar(const int &_index, char &out_parameter_);
        int getUserParaFloat(const int &_index, float &out_parameter_);
        int getUserParaDouble(const int &_index, double &out_parameter_);

        int setUserCommand(const int &_set_command);
        int setUserParaInt(const int &_index, const int &_set_parameter);
        int setUserParaChar(const int &_index, const char &_set_parameter);
        int setUserParaFloat(const int &_index, const float &_set_parameter);
        int setUserParaDouble(const int &_index, const double &_set_parameter);

        int getTotalCommand(COMMAND_STRUCT &out_command_structure_);
        COMMAND_STRUCT getTotalCommand(const int &_target_processId);

        int sendCommand_internal(const int &_target_processID);
        int sendCommand_tcp(const int &_target_processID);


    private:
        RBQ_API* m_parent = nullptr;  // RBQ_API class pointer

        COMMAND_STRUCT m_command;
        int* m_socket = nullptr;
    };
    Command command{this};

    int getBatteryVoltage(float &out_battery_voltage_);

private:
    pRBCORE_SHM_COMMAND     m_sharedCMD            = nullptr;
    pRBCORE_SHM_REFERENCE   m_sharedREF            = nullptr;
    pRBCORE_SHM_SENSOR      m_sharedSEN            = nullptr;
    pUSER_SHM               m_sharedUSER           = nullptr;
    pMotion2Network         m_sharedMotion2Net     = nullptr;
    int                     m_shmOpened            = 0;
    int _openSHM();

    int m_processId = -1;
    int m_connected = 0;

private:
    template <typename T>
    static const T& clamp(const T& value, const T& low, const T& high)
    {
        return (value < low) ? low : (value > high) ? high : value;
    }

    static constexpr float FLOAT_EPSILON = 1e-4f;
    static bool floatEquals(float a, float b)
    {
        return std::abs(a - b) <= FLOAT_EPSILON;
    }
    void setUserCommand(const COMMAND_STRUCT &cmd);

#endif // PRIVATE
};

#endif // RBQ_API_H
